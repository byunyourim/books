# Singleton
인스턴스를 오직 하나만 생성할 수 있는 클래스

생성자를 private로 만들어 외부에서 new로 호출하지 못하도록 static method로 사용


#### 한계
1. private 생성자를 갖긱 때문에 상속할 수 없다.
2. 테스트가 어렵다
3. 서버환경에서 싱글턴이 하나만 만들어지는 것을 보장할 수 없다.
4. 전역 상태를 만들 수 있기 때문에 바람직하지 않다.


### 싱글턴 사용 이유
한번의 객체 생성으로 재사용이 가능하기 때문에 메모리 낭비를 방지할 수 있다.
또한 싱글톤으로 생성된 객체는 무조건 한 번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이하다.


## 생성 방식
### 1. public static 멤버가 final 필드인 방식
```
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }

	public void leaveTheBuilding()
}
```
private 생성자는 public static final 필드 INSTANCE를 초기화할 때 한 번 호출된다.
public, protected 생성자가 없으므로 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나임이 보장된다.

하지만 리플렉션 API AccessibleObject.setAccessible을 사용해 private생성자를 호출할 수 있다.

> AccessibleObject.setAccessible() 메서드:
> 이 메서드는 클래스의 private 필드, 메서드, 생성자 등에 대한 접근 제어를 우회할 수 있게 해줍니다.


```
// Elvis 클래스의 생성자 가져오기
Constructor<Elvis> constructor = Elvis.class.getDeclaredConstructor();
// 접근 가능하도록 설정
constructor.setAccessible(true);

// 새로운 인스턴스 생성
Elvis newInstance = constructor.newInstance();
System.out.println("New Elvis instance: " + newInstance);
System.out.println("Original INSTANCE: " + Elvis.INSTANCE);
```

이것을 해결하기 위해 두 번째 객체가 생성되려할 때 예외를 던질 수 있다.
```
private Elvis() {
  if(INSTANCE != null){
    throw new RuntimeException("생성자를 호출할 수 없습니다.");
  }
}
```

<br>

### 2. 정적 팩터리 메서드를 public static 멤버로 제공하는 방식
```
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() { return INSTANCE; }

	public void leaveTheBuilding()
}
```
getInstance()는 항상 같은 객체의 참조를 반환하기 때문에 제 2 Elvis인스턴스가 만들어지지 않는다.

API를 수정없이 private static이 아닌 다른 새 인스턴스 생성을 통해 싱글턴이 아니게 변경할 수 있다.
또한, 정적 팩터리의 메서드 참조를 Supplier로 사용할 수 있다.
```
Supplier<Elvis> elvisSupplier = Elvis::getInstance;
Elvis elvis = elvisSupplier.get();
```
이것은 정적 팩토리 메서드 getInstance()의 메서드 참조를 Supplier로 바인딩하여, 객체 생성 시점에서 이를 유연하게 사용한다.
객체 생성의 책임을 분리하고, 필요에 따라 다양한 방식으로 인스턴스를 생성하거나 주입할 수 있어 의존성 주입(DI)나 함수형 프로그래밍에서 유용하다.


하지만 위의 두 방식은 각 클래스를 직렬화한 후 역직렬화할 때 새로운 인스턴스를 만들어서 반환하다.
이를 방지하기 위해 readResolve 에서 싱글턴 인스턴스를 반환하고, 모든 필드에 transient 키워드를 추가해야 한다.

싱글턴 클래스를 직렬화하기 위해서는 모든 필드에 transient를 선언하고 readResolve메서드를 제공해야 한다.
```
private Object readResolve() {
  return Instance;
}
```

<br>


### 3. 원소가 하나인 열거 타입을 선언하는 방식
```
public enum Elvis {
	INSTANCE; 
	
	public void doSomething() {
    System.out.println("Singleton instance is doing something.");
  }
}
```

```
public class Main {
  public static void main(String[] args) {
      Singleton instance = Elvis.INSTANCE;

      // 메서드 호출
      instance.doSomething();
  }
}
```
이 방식은 복잡한 직렬화 상황이나 리플렉션 공격에도 제 2의 인스턴스가 생성되는 것을 막아준다.
단, 만드는 싱글턴이 Enum 이외의 다른 상위 클래스를 생성해야 하는 경우 사용할 수 없다.

