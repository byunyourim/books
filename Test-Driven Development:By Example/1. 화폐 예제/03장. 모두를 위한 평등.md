Dollor객체와 같이 객체를 값처럼 쓸 수 있는 것을 값 객체 패턴 (Value Object Pattern)이라고 한다.  

값 객체 패턴에 대한 제약 사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해 설정이 되면 결코 변하지 않는다는 것이다.
- 불변성
- 동일성


값 객체는 모든 연산이 새 객체를 반환해야 한다. 또한 equals() 메서드를 구현해야 한다. 만약
HashMap()와 같은 해시 테이블의 키로 쓸 것이라면 hashCode() 메서드를 같이 구현해야 한다.  


<br>

#### equals() 메서드의 테스트 코드는 아래와 같이 구현할 수 있다.
```java
public void testEquality() {
  assertTrue(new Dollor(5).equals(new Dollor(5)));
}
```

<br>

#### 가짜 구현 
```java
public boolean equals(Object obj) {
  return true;
}
```

<br><br>


예

### 삼각 측량
세 점을 기준으로 각도와 거리를 이용해 특정 지점의 위치를 계산하는 방법  

- **예제가 두 개 이상 있어야만 코드를 일반화 할 수 있다.**
- 두 번째 예제가 좀 더 일반적인 해를 필요로 할 때 일반화한다.


어떤 한 라디오 송신국에서 두 개의 수신국으로 라디오를 쏘면 송신국의 정확한 위치를 알 수 있는 방법이다.
리팩토링이 힘들때는 삼각 측량 방법을 이용할 수 잇따. 

testEquality()에서는 무조건적으로 통과할 수 밖에 없다. 
return true이기 때문!!  


하지만 동작하는 코드가 되기 위해서는 적절한 로직이 필요하다.  
```java
public void testEquality() {
    assertTrue(new Dollar(5).equals(new Dollar(5)));
    assertFalse(new Dollar(5).equals(new Dollar(10)));
}
```
위의 테스트에 성공하기 위해서는 실제 로직을 짜야한다.




삼각 측량은 사실 중복되는 코드가 발생할 수 밖에 없다.
원래라면 테스트를 한 번에 통과시키고 잘 동작하는 코드를 짜는게 맞지만, 그렇지 못할 경우도 발생한다.
켄트 벡은 삼각 측량이 항상 쓰이는 것은 비효율적이라고 생각하기 때문에 꼭 필요할 때 사용해야 한다고 한다.
(리팩토링을 어떻게 수행해야할지 생각이 나지 않을 떄)  

지금 설계하는 프로그램에 어떤 변화 가능성을 지원해야 하는가? 몇몇 부분을 변경시켜보면 답이 명확해진다.
```java
public boolean equals(Object obj) {
  Dollar dollar = (Dollar) obj;
  return amount == dollar.amount; 
}
```


