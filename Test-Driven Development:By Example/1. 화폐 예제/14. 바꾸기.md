추가적으로 2프랑을 달러로 바꾸고 싶으면 어떻게 해야 할까?
이에 대한 테스트 코드를 작성해보면 다음과 같다.

```java
public void testReduceMoneyDifferentCurrency() {
    Bank bank = new Bank();
    bank.addRate("CHF", "USD", 2);
    Money result = bank.reduce(Money.franc(2), "USD");
    assertEquals(Money.dollar(1), result);
}

```

<br>

컴파일을 빠르게 해결하기 위해서는 Bank 클래스에 addRate 함수를 추가해야 한다.

```java
public void addRate(String from, String to, int rate) {

}
```

<br>

그리고 가장 빨리 초록 막대를 보기 위한 방법은 환율 계산 정보를 Money 클래스의 reduce에 추가하는 것이다.

```java
public Money reduce(String to) {
    int rate = (currency.equals("CHF") && to.equals("USD"))
            ? 2
            : 1;
    return new Money(amount / rate, to);
}
```

<br>

이렇게 코드를 작성하면 초록 막대를 볼 수는 있다. 하지만 Money가 환율에 대해 알게 되었다. 이러한 구조는 적합하지 않으며, 환율에 대한 처리는 Bank에서 하는 것이 옳다.
그렇기에 이를 호출하는 부분을 Bank 클래스에 작성하면 다음과 같다
```java
Money reduce(Expression source, String to) {
    return source.reduce(this, to);
}
```

<br>

이러면 컴파일 에러가 발생할 것이다. 이를 해결하기 위해 Expression과 Bank 클래스 그리고 Sum 클래스의 reduce에 첫 번째 파라미터를 추가해야 한다.
```java
Expression Interface
Money reduce(Bank bank, String to);

Money Class
public Money reduce(Bank bank, String to) {
    int rate = (currency.equals("CHF") && to.equals("USD"))
            ? 2
            : 1;
    return new Money(amount / rate, to);
}

// Sum Class
@Override
public Money reduce(Bank bank, String to) {
    return null;
}
```

<br>

그러면 이제 Money 클래스에서 Bank를 파라미터로 받으므로, 환율의 계산을 Bank에게 맞길 수 있다. 그렇기에 다음과 같은 환율 계산 메소드를 Bank 클래스에 추가해주자.
```java
int rate(String from, String to) {
    return (from.equals("CHF") && to.equals("USD"))
        ? 2
        : 1;
}
```

<br>

그러면 이제 현재 Money가 환율에 의존하는 코드는 필요가 없으므로, Money 클래스에서 관련 코드를 수정해주도록 하자.
```java
Money Class
public Money reduce(Bank bank, String to) {
    int rate = bank.rate(currency, to);
    return new Money(amount / rate, to);
}
```

<br>

이제 실행하면 초록 막대가 나오겠지만, 아직 Bank가 환율에 대해 직접적으로 알고 있다는 것은 좋지 않다. 이를 관리하기 위한 별도의 클래스를 생성하고자 한다.
```java
public class Pair {

    private String from;
    private String to;

    public Pair(String from, String to) {
        this.from = from;
        this.to = to;
    }
}
```

<br>

그리고 Pair를 Key로 쓰고, 그에 대한 환율을 꺼내야 하므로 equals와 hashCode를 구현해야 한다. (지금은 리팩토링하는 중에 코드를 작성하는 것이므로, 테스트를 작성하지는 않는다.)

```java
@Override
public boolean equals(Object object) {
    Pair pair = (Pair) object;
    return from.equals(pair.from) && to.equals(pair.to);
}

@Override
public int hashCode() {
    return 0;
}
```

<br>

여기서 0을 반환하는 해시코드는 최악이다. 해시코드가 0이라면 선형 탐색처럼 해시테이블에서 탐색을 할 테지만, 가짜로 구현해두고 넘어가도록 하자.
그리고 은행에서는 환율을 저장하기 위핸 객체가 필요하다. 그렇기에 환율 저장을 위한 HashTable 인스턴스 변수를 추가하고, addRate와 rate 함수를 마무리하도록 하자.

```java
private Hashtable<Pair, Integer> rates = new Hashtable<>();

public void addRate(String from, String to, int rate) {
    rates.put(new Pair(from, to), rate);
}

int rate(String from, String to) {
    Integer rate = rates.get(new Pair(from, to));
    return rate.intValue();
}
```

<br>

하지만 테스트 코드를 실행하면 실패한다. 그 이유는 USD에서 USD로의 환율이 1이 되어야 하기 때문이다. 이에 대한 테스트 코드를 다음과 같이 추가하자.
```java
public void testIdentityRate() {
    assertEquals(1, new Bank().rate("USD", "USD"));
}
```

<br>

그리고 Bank 클래스의 rate 함수에는 다음과 같이 동일할 경우 1로 반환하는 코드를 넣어주자.
```java
int rate(String from, String to) {
    if(from.equals(to)) return 1;
    Integer rate = rates.get(new Pair(from, to));
    return rate.intValue();
}
```
