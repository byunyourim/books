현재 코드 중복은 없지만 데이터 중복은 있다.

하지만 아직 잘 감이 오지 않으므로, 테스트 코드부터 손보도록 하자.
우선 Expression 으로 반환되는 결과는 덧셈에 대한 표현이고, 이를 위해서는 덧셈의 구현체가 필요하다. 그리고 그 구현체는 더할 두 대상을 저장하고 있어야 할 것이다.
두 화폐의 덧셈을 위한 테스트 코드를 작성하면 다음과 같다.

```java
public void testPlusSimpleAddition() {
    Money five = Money.dollar(5);
    Expression result = five.plus(five);
    Sum sum = (Sum) result;
    assertEquals(five, sum.augend);
    assertEquals(five, sum.addend);
}
```

<br><br><br>
위 코드는 내부 구현에 깊이 관여하고 있어 추후 수정이 필요하다.  
우선 컴파일 에러를 잡기 위해 Sum 클래스를 생성하자.
```java
public class Sum {
  Money augend;
  Money addend;
}
```



<br><br><br>

현재 Money의 plus는 Sum이 아닌 Money를 반환하고 있으므로 ClassCastException이 발생한다. 
그렇기에 Money 클래스의 plus 함수가 Sum을 반환하도록 변경하자.
```java
Expression plus(Money addend) {
  return new Sum(this, addend);
}
```



<br><br><br>

Sum 생성자를 추가하자.
또한 Sum은 Expression의 일종이어야 하기 때문에 Expression을 구현하자.
```java
public class Sum implements Expression {
  Money augend;
  Money addend;

  Sum(Money augend, Money addend) {
  }
}
```

<br><br><br>
이제 컴파일은 해결 되었지만 테스트는 실패한다. 왜냐하면 생성자에서 필드를 설정하지 않았기 때문이다. 그렇기에 Sum의 생성자를 수정해주도록 하자.
```java
Sum(Money augend, Money addend) {
    this.augend = augend;
    this.addend= addend;
}
```


<br><br><br>

이제 reduce는 Sum을 전달받게 된다. 
만약 Sum이 가지고 있는 통화가 동일하며, reduce를 통해 얻고자 하는 통화 역시 동일하다면, 
결과는 Sum 내에 있는 Money들의 amount를 합친 Money 객체여야 할 것이다. 그렇기에 reduce에 대한 테스트 코드를 작성하도록 하자.
```java

public void testReduceSum() {
    Expression sum = new Sum(Money.dollar(3), Money.dollar(4));
    Bank bank = new Bank();
    Money result = bank.reduce(sum, "USD");
    assertEquals(Money.dollar(7), result);
}
```


<br><br><br>

위의 테스트 코드는 실패한다. 그렇기에 우리는 이를 통과하기 위한 Bank의 reduce를 구현해주어야 한다.

```java
Money reduce(Expression source, String to) {
    Sum sum = (Sum) source;
    int amount = sum.augend.amount + sum.addend.amount;
    return new Money(amount, to);
}
```

<br><br><br>
하지만 위의 코드는 다음의 두가지 이유로 깔끔하지 못하다.

이 코드는 Sum으로 캐스팅하므로, 모든 Expression에 대해 동작하지 못한다.
public 필드와 그 필드들에 대해 2단계에 걸쳐 접근한다.

위의 문제를 해결하는 것은 간단하다. 우선 2단 참조를 줄이기 위해 Sum에서 reduce를 구현하여 호출하도록 하는 것이다. 그렇기에 다음과 같이 수정해주도록 하자.
```java
Bank Class
Money reduce(Expression source, String to) {
    Sum sum = (Sum) source;
    return sum.reduce(to);
}

Sum Class
public Money reduce(String to) {
    int amount = augend.amount + addend.amount;
    return new Money(amount, to);
}
```




<br><br><br>
Bank.reduce()의 인자로 Money를 넘겼을 경우에는 어떻게 처리해야 할까? 이에 대한 테스트 코드를 작성하도록 해보자.
```java
public void testReduceMoney() {
    Bank bank = new Bank();
    Money result = bank.reduce(Money.dollar(1), "USD");
    assertEquals(Money.dollar(1), result);
}
```

<br><br><br>
그리고 이를 통과하려면 Bank의 reduce를 다음과 같이 수정해야 한다.

```java
Money reduce(Expression source, String to) {
    if(source instanceof Money) return (Money) source; 
    Sum sum = (Sum) source;
    return sum.reduce(to);
}

```

<br><br><br>

이렇게 코드를 작성하면 다행히 테스트는 통과한다. 그러므로 이제 이를 리팩토링 해보도록 하자.
클래스를 명시적으로 검사하는 코드가 있을 때에는 항상 다형성을 사용하도록 하는 것이 좋다. Sum은 reduce(String)를 구현하므로, Money도 그것을 구현하도록 만든다면 reduce()를 Expression 인터페이스에도 추가할 수 있다.
```java
Money Class
public Money reduce(String to) {
    return this;
}

Expression Interface
Money reduce(String to);

Bank Class
Money reduce(Expression source, String to) {
    return source.reduce(to);
}
```


<br><br><br>
Expression과 Bank에 이름은 동일하지만 매개변수만 다른 함수가 있다는 것은 불만족스럽다. 파이썬은 이를 매끄럽게 해결할 수 있지만, Java에서는 만족스러운 해법이 없는 것 같다.
지금까지 나온 클래스와 인터페이스를 정리하고 나면 다음과 같다.
```java
public class Bank {
    Money reduce(Expression source, String to) {
        return source.reduce(to);
    }
}

public interface Expression {
    Expression plus(Money addend);
    Money reduce(String to);
}

public class Money implements Expression {
    protected int amount;
    protected String currency;

    Money(int amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    private String currency() {
        return currency;
    }

    static Money dollar(int amount) {
        return new Money(amount, "USD");
    }

    static Money franc(int amount) {
       return new Money(amount, "CHF");
    }

    @Override
    public boolean equals(Object object) {
        Money money = (Money) object;
        return amount == money.amount && currency().equals(money.currency());
    }

    public Money times(int multiplier) {
        return new Money(amount * multiplier, currency);
    }

    Expression plus(Money addend) {
        return new Sum(this, addend);
    }

    public Money reduce(String to) {
        return this;
    }

}

public class Sum implements Expression {
    Money augend;
    Money addend;

    Sum(Money augend, Money addend) {
        this.augend = augend;
        this.addend= addend;
    }

    public Money reduce(String to) {
        int amount = augend.amount + addend.amount;
        return new Money(amount, to);
    }
}

```
