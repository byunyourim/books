times()를 처리해보자.

times() 가 Money를 반환하도록 하면 비슷한 코드가 된다.
```java
// Franc.class
Money times(int multiplier) {
  return new Franc(amount * multiplier);
}

// Dollar.class
Money times(int multiplier) {
  return new Dollar(amount * multiplier);
}

```

이렇게 되면 Money의 두 하위 클래스를 제거해도 될 것 같다.

하위 클래스에 대한 직접적인 참조가 적어지면 하위 클래스에 대한 제거가 용이해진다. 직접 참조를 제거하기 위해
Money에 Dollar 를 반환하는 팩토리 메서드를 도입하자

```java
// Money.class
static Dollar dollar(int amount) {
  return new Dollar(amount);
}
```

<br>

```java
public void testMultiplication() {
  Money five = Money.dollar(5);
  assertEquals(new Dollar(10), five.times(2));
  assertEquals(new Dollar(15), five.times(3));
}
```

<br>

하지만 아직 times가 Money에 존재하지 않으므로 컴파일 에러가 발생한다. 
아직 times를 구현할 준비가 되지 않았기 때문에, Money 를 추상 클래스로 변경하고 추상 메서드 times()를 선언하자.  

```java
public abstarct class Money {
  abstarct Money times(int multiplier);
}
```


<br>

그리고 Dollar를 반환하는 팩토리 메서드의 반환 클래스를 Money로 수정하자.
```java
static Money dollar() {
  return new Dollar(amount);
}
```

<br>

그리고 Dollar를 직접 참조하는 다른 테스트 코드에서 역시 팩토리 메소드를 사용하도록 변경하면 코드가 한층 괜찮아진다.  
(어떤 클라이언트 코드도 Dollar라는 하위 클래스의 존재를 모른다.)  

그리고 testFrancMultipication 역시 팩토리 메소드를 작성하여 변경하려고 보니, Dollar에 의해 모든 테스트가 검사되어 지워도 될 것 같다.    
하지만 일단 남겨두도록 하고, testFrancMultipication를 수정하도록 하자.

```java
static Money fracn(int amount) {
  return new Franc(amount);
}
```

<br>


```java
public void testFrancMultiplication() {
  Money five = Money.franc(5);
  assertEquals(Money.franc(10), five.times(2));
  assertEquals(Money.franc(15), five.times(3));
}
```

<br>


그리고 이제 times를 제거해보자



