- 테스트를 한다는 것은 무엇을 뜻하는가?
- 테스트를 언제해야 하는가?
- 테스트할 로직은 어떻게 고를 것인가?
- 테스트할 데이터를 어떻게 고를 것인가?


<br><br><br>
### 테스트 (명사)
테스트하다(testt)는 '평가하다' 라는 뜻의 동사이다.
그 어떤 소프트웨어 엔지니어도, 아무리 작은 변화라도 테스트하지 않고 릴리즈하지 않는다.  
변화를 테스트할 수 있다고 해도, 실제로 변화를 테스트하는 것은 '테스트를 갖고 있다' 는 것과 같지 않다.



<br><br><br>

### 격리된 테스트
테스트를 실행하는 것이 어떤 식으로 영향을 미쳐야 좋은가?  
아무 영향이 없어야 한다.  

각각의 테스트는 다른 테스트와 독립적이어야 한다.   

격리된 테스트가 암묵적으로 내포하는 특징 중 하나는 테스트가 실행 순서에 독립적이라는 것이다.

성능 문제는 테스트가 데이터를 공유해야 하는 이유로 자주 언급된다.  
격리된 테스트가 내포하는 것이 하나 더 있는데 , 이것은 주어진 문제를 작은 단위로 분리하기 위해
각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있어야 한다는 것이다.  

테스트를 격리하기 위한 작업은 결과적으로 시스템 응집도는 높고, 결합도는 낮은 객체의 모음으로 구성되도록 한다.



<br><br><br>

### 테스트 목록 
무엇을 테스트해야 할까?  

시작하기 전에 테스트 목록을 모두 적어두자.  

우선 구현할 필요가 있는 모든 오퍼레이션의 사용 예들을 적는다.  
그 다음, 아직 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전을 리스트에 적는다.  
마지막으로, 리팩토링 목록을 적는다.  

테스트의 윤곽만 잡는 대신, 한 걸음 더 나아가 테스트를 전부 구현할 수도 있다.   
하지만 실제로 초록 막대를 보는데 시간이 소요되기 때문에 추천하지는 않는다.  

테스트를 통과하는 과정에서 우리가 작성한 코드들이 새로운 테스트가 필요함을 알려준다.  
이 새 테스트를 리팩토링과 마찬가지로 할 일 목록에 적자.
세션이 끝났을 때 목록에 남아있는 항목들은 따로 신경 쓸 필요가 있다.  

어떤 기능을 진행중이라면 다음에도 똑같은 목록을 사용하라.
현재 작업 범위를 넘어서는 큰 리팩토링 목록을 발견하면, 다음 할 일 목록으로 옮기자.




<br><br><br>

### 테스트 우선
테스트를 언제 작성하는 것이 좋을까?  

테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.  
코드를 작성한 후에는 테스트를 만들지 않을 것이다.  




<br><br><br>

### 단언 우선  
테스트를 작성할 때 단언(assert)는 언제 사용할까?  

단언을 제일 먼저 쓰고 시작하자.  
- 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 것이라고 알려주는 것부터 작성한다.
- 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.
- 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

단언을 작성하면 작업은 단순하게 만들 수 잇다.   

구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 사실 우리는 몇 가지 문제를 한 번에 해결하는 것이다.  
- 테스트하고자 하는 기능은 어디에 속하는 것일까?
- 메서드 이름은 뭐라고 해야 하나?
- 올바른 결과를 어떤 식으로 검사할 것인가?
- 이 테스트가 제안하는 또 다른 테스트에는 무엇이 있을까?

위의 문제들을 한 번에 해결하는 것은 쉽지 않다.   


<br>

예를 들어, 소켓을 통해 다른 시스템과 통신하려 한다고 가정해보자.
통신을 마친 후, 소켓은 닫혀 있고, 소켓에서 문자열 'abc'를 읽어와야 한다고 하자.

```java
testCompleteTransaction() {
    ....
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

reply는 어디에서 얻어 올까?
socket에서 얻어온다.
```java
testCompleteTransaction() {
    ....
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

그러면 소켓은 어디에서 나올까? 
서버에 접속할 때 생성된다.
```java
testCompleteTransaction() {
    ...
    Socket reader = Socket("localhost", defaultPort());
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

이 작업을 하기 전 서버를 열어야 한다.
```java
testCompleteTransaction() {
    Server writer = Server(defaultPort(), "abc");
    Socket reader = Socket("localhost", defaultPort());
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```
지금까지 아주 작은 단계로 빠른 피드백을 받아 테스트의 아웃라인을 만들었다.   





<br><br><br>

### 테스트 데이터
테스트할 때 어떤 데이터를 사용해야 할까?  

테스트를 읽을 때 쉽고 따라가기 좋을만한 데이터를 사용하라
데이터 작성에도 청중이 존재한다.   
단지 데이터 값을 산발하기 위해 데이터값을 산발하지 마라. 데이터 간 차이가 있다면 그 속에 어떤 의미가 있어야 한다.
(1과 2 사이에 어떠한 개념적 차이가 없다면 1을 사용하자)  

테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 사용하지 않는 것이다.   
만약 plus() 메서드를 구현하려고 한다면 고전적인 예제인 1+1, 2+2를 사용하고 싶을 것이다.   

만약 구현 인자의 순서가 뒤바뀐다면 어떨까?  
plus에서는 상관없지만 다른 메서드에서는 아닐 수 있다.   
따라서 첫 번째 인자를 2로 사용했다면 두 번째 인자는 3을 사용해야 한다.     

테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. 
실제 데이터의 유용성에는 아래와 같은 것이 있다. 
- 실제 실행을 통해 수집한 외부 이벤트 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우
- 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우
- 시뮬레이션 시스템을 리팩토링한 후 기존과 동일한 결과가 나오는지 확인하고자 하는 경우
- (부동소수점)

  

<br><br><br>

### 명백한 데이터
데이터의 의도를 어떻게 표현할 것인가?

테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.  

테스트를 작성할 때는 컴퓨터 뿐 아니라 후에 코드를 읽을 다른 사람도 생각해야 한다.   


예로, 한 통화를 다른 통화로 환전하려고 하는데, 이 거래에는 수수로 1.5가 붙는다.  
USD에서 GBP로 교환하는 환율이 2:1이라면, 
$100를 환전하려면 50GBP - 1.5% = 49.25GBP여야 한다. 
```java
Bank bank = new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result = bank.convert(new Note(100, "USD"), "GBP);
assertEquals(new Note(49.25, "GBP"), result);
```

```java
Bank bank = new Bank();
bank.addRate("USD", "GBP", 2);
bank.commission(0.015);
Money result = bank.convert(new Note(100, "USD"), "GBP");
assertEquals(new Note(100 / 2 * (1 - 0.015), "GBP"), result);
```


이 테스트에서 입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 읽어낼 수 있다.  

명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는 것이다.   
단언 부분에 수식을 써놓으면 다음으로 무엇을 해야 할지 쉽게 알 수 잇다.   

이 경우 어떻게든 나눗셈, 곱셈을 수행할 프로그램을 만들어야 한다는 것을 알 수 있다.   


명백한 데이터는 코드에 매직넘버를 쓰지 말라는 것에 대한 예외적인 규칙일 수도 있다.   
단일 메서드의 범위에서라면 어떤 매직넘버 사이의 관계는 명백하다. 하지만 이미 정의된 기호 상수가 있다면 나는 그것을 사용할 것이다. 
