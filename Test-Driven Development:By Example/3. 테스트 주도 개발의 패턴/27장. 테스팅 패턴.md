### 자식 테스트
지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까?

원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하자.  

그 후 원래의 다시 큰 테스트케이스를 추가하자.  




<br><br><br>

### 모의 객체
비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야 할까?  
상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다.  

데이터베이스는 시작 시간이 오래 걸리고, 깨끗한 상태로 유지하기가 어렵다.   
그리고 데이터베이스가 원격 서버에 있다면, 테스트로 인해 네트워크 상의 물리적 위치에 영향을 받게 된다.  
데이터베이스는 개발 중 많은 오류의 원인이 된다.  

해결 방안은 진짜 데이터베이스를 사용하지 않는 것이다.   
대다수의 테스트에서는,   
데이터베이스인 것처럼 행동하지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다.  

```java
public void testOrderLookup() {
    Database db = new MockDatabase();
    db.expectQuery("select order_no from Order where cust_no is 123");
    db.returnResult(new String[] {"Order 2", "Order 3"});
    ...
}
```

성능과 견고함 외 모의 객체의 또 다른 가치는 가독성이다.  

모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다.  

모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까? 
모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다.



<br><br><br>

### 셀프 션트
한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 해야 할까?  

테스트 대상이 되는 객체가 원래 대화 상대가 아닌 테스트 케이스와 대화하도록 하면 된다.

UI 객체를 TestResult와 연결할 수 있다면 테스트가 실행된 시점, 
테스트가 실패한 시점, 전체 테스트 슈트가 시작되고 끝난 시점 등을 통보 받을 수 있을 것이다.   
```python
// ResultListenerTest
def testNotification(self):
    result = TestResult()
    listener = ResultListener()
    result.addListener(listener)
    WasRun("testMethod").run(result)
    assert 1 == listener.count
```

이 테스트가 수행되려면 이벤트 통보 횟수를 셀 객체가 필요하다.
```python
// ResultListener
class ResultListener:
    def__init__(self):
        self.count= 0
    def startTest(self):
        self.count= self.count + 1
```
그런데 왜 이벤트 리스너를 위해 별도의 객체를 만들어야 하는 걸까?   
그냥 테스트 케이스 자체를 리스너로 쓰면 될 텐데 말이다.  
  
즉 테스트 케이스가 일종의 모의 객체 노릇을 하는 것이다. 
```python
// ResultListenerTest
def testNotification(self):
    self.count = 0
    result= TestResult()
    result.addListener(self)
    WasRun("testMethod").run(result)
    assert 1 == self.count
def startTest(self):
    self.count= self.count + 1
```
 
셀프 션트 패턴을 이용해 작성한 테스트가 그렇지 않은 테스트보다 읽기에 더 수월하다.  

위의 테스트가 좋은 예다.   
두 번째 버전의 테스트 메서드는 통보 횟수에 대한 두 값이 한곳에 모여 있는 반면, 
첫 번째 버전의 테스트 메서드에서는 하나의 클래스에서 횟수를 0으로 설정하고 다른 클래스에서 1이 예상치임을 나타낸다. 

셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출(Extract Interface)을 해야 한다. 
(인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 사용자의 몫이다) 

셀프션트를 위해 추출해 낸 인터페이스는 여러 곳에서 쓰이는 경우가 많다.   

자바의 경우, 셀프 션트를 사용한 결과로 인터페이스 안의 온갖 기괴한 메서드들을 다 구현한 테스트들을 보게 될 것이다.

낙관적 타입 시스템을 가진 언어(동적인 타입 검사를 수행하는 언어들)에서는 테스트 케이스 클래스가 실제로 테스트를 수행하는데 꼭 필요한 오퍼레이션들만 구현하면 된다. 
하지만 자바에서는 빈 메서드라도 인터페이스의 모든 오퍼레이션들을 구현해야 한다. 
그러므로 가능한 한 인터페이스를 작게 만들길 원할 것이다. 
인터페이스에 대한 구현은 또한 적절한 값을 되돌리거나 부적절한 오퍼레이션이 호출된 경우 예외를 던지게끔 만들어야 할 것이다.


<br><br><br>

### 로그 문자열
메시지의 호출 순서가 올바른지 검사하려면 어떻게 해야 할까?   
  
로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다.   


xUnit에서 쓴 예제를 사용할 수 있다. 
setUp(),   
테스트를 수행하는 메서드,   
tearDown() 순서로 호출되길 원하는 템플릿 메서드(Template Method)가 있다.   
  
  각 메서드들이 로그 문자열에 자기 이름을 추가하게 구현하면 쉽게 읽히는 테스트를 만들 수 있다. 

```python
def testTemplateMethod(self):
  test= WasRun("testMethod")
  result= TestResult()
  test.run(result)
  assert("setUp testMethod tearDown " == test.log)
```
구현 또한 간단하다. 
```python
//WasRun
def setUp(self):
  self.log= "setUp "
def testMethod(self):
  self.log= self.log + "testMethod "
def tearDown(self):
  self.log= self.log + "tearDown "
```
로그 문자열은 특히 옵저버(Observer)를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다.   

만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없다면 문자열 집합을 저장하고 있다가 단언(assertion)에서 집합 비교를 수행하면 된다. 
  
로그 문자열은 셀프 션트와도 잘 작동한다.   
해당 테스트 케이스는 로그를 추가하고 적절한 값을 반환하는 식으로 셀프 션트한 인터페이스의 메서드를 구현한다. 



<br><br><br>

### 크래시 테스트 더미
호출되지 않을 것 같은 에러코드(발생하기 힘든 에러 상황)를 어떻게 테스트할 것인가?  
실제 작업을 수행하는 대신 그냥 예외를 발생시키기만하는 특수한 객체를 만들어서 이를 호출한다.     


파일 시스템에 여유 공간이 없을 경우 발생할 문제에 대해 테스트하기를 원한다고 생각해보자.  
1)실제로 큰 파일을 많이 만들어서 파일 시스템을 꽉 채울 수도 있고,  
2)가짜 구현(fake it)을 사용할 수도 있다. 
그냥 시뮬레이션한다고 가정하자.   
파일을 위한 크래시 테스트 더미(Crash Test Dummy)는 다음과 같다. 
```java
private class FullFile extends File {
    public FullFile(String path) {
        super(path);
    }
    
    public boolean createNewFile() throws IOException {
        throw new IOException();
    }
}
```


```java
public void testFileSystemError() {
    File f = new FullFile("foo");
    try {
        saveAs(f);
        fail();
    } catch (IOException e) {
    }
}
```

객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.  
자바의 익명 클래스(anonymous innerclass)는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생시키게끔 하기 위해 유용하게 쓰인다.   
테스트 케이스 안에서 원하는 메서드 하나만 재정의할 수 있다.   
이렇게 하면 테스트 읽기가 수월해진다. 
```java
public void testFileSystemError() {
    File f = new File("foo") {
        public boolean createNewFile() throws IOException {
            throw new IOException();
        }
    };
    try {
        saveAs(f);
        fail();
    } catch (IOException e) {
    }
}
```


<br><br><br>

### 깨진 테스트
혼자서 프로그래밍 할 때 프로그래밍 세션을 어떤 상태로 끝마치는게 좋을까? 
  
마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.  
나중에 다시 코딩하기위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. 
깨진 테스트가 있다고해서 완성도가 떨어지는 것이 아니며, 단지 프로그램의 상태를 표시할 뿐이다.



<br><br><br>

### 깨끗한 체크인
팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?   
  
모든 테스트가 성공한 상태로 끝마치는 것이 좋다.     

따라서 코드를 체크인하기 전 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다.
체크인은 자주하는 것이 좋다.  

테스트 슈트를 통과시키기 위해 주석 처리하는 것은 금지다.



