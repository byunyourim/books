# 안정 해시 설계 
수평적 규모 확장성을 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다.  





<br><br>

## 해시 키 재배치 문제
N개의 캐시 서버가 있다고 하자ㅏ.  

이 서버들에 부하를 균등하게 나누는 보편적인 방법은 아래의 해시함수를 사용하는 것이다.
  
**serverIndex = hash(key) % N (N은 서버 개수)**



서버가 4개라고 하면 0~3 사이의 값을 내어 해당 서버 인덱스를 가진다.

<br>

모듈러 연산은 다음 가정 하에 균등하다.

- 서버 풀 크기 고정
- 데이터의 분포가 균등


하지만 서버가 추가되거나 기존 서버가 삭제되면 문제가 생긴다.  


예를 들어 서버가 4개(s0, s1, s2, s3)가 있었는데 s1이 장애가 발생했다고 하자.  
그럼 정상 서버 개수가 3이 되고, 이는 모듈러 연산의 N값이 바뀌게 된다.  
다시 말해서, s0, s2, s3에 요청을 보내던 키 또한 새로 연산된다.    
   
이럴 경우에, 캐시 클라이언트가 소용없게 된다.    
즉 많은 요청에서 대규모 캐시 미스가 발생하는 문제가 발생하게 된다.  
  
이를 해결하는 기술이 안정 해시 기술이다.  


> #### 캐시미스
> 캐시에서 요청한 데이터가 존재하지 않는 경우를 말한다.




<br><br>


## 안정 해시
일관된 해시라고도 불린다. 분산 캐싱을 위해 등장.

### 안정 해시 기술이 해결하려는 문제는?
서버 추가, 삭제에 따른 재배치해야 할 해시 키(데이터) 양을 줄이기 위함.
스케일 아웃에 용이하며, 해시 키 재배치 시, 재배치 키들이 적어지고 균등하게 분포됨.

즉, 해시 테이블 크기 조정이 이루어지면 평균적으로 오직 **k/n** 개의 키만 재배치하는 기술.
- k: 키(아이템) 개수
- n: 전체 노드 개수



<br>


#### 가정
해시 함수 f로 SHA-1을 사용  
함수의 출력 값 범위는 x0, x1, ..., xn  

> #### SHA-1(Secure Hash Algorithm 1)
> 입력을 받고 메시지 다이제스트라는 160비트(20바이트) 해시값을 만드는 암호화 해시 함수로,  
> 보통은 16진수 40자리로 렌더링된다.


<br>

### 해시 공간과 해시 링

<img width="705" alt="스크린샷 2024-10-21 오후 4 57 43" src="https://github.com/user-attachments/assets/e7100067-532b-4a6b-a67f-b305f6d18f5e">

#### 해시 공간과 해시 링
- SHA-1의 해시 공간 범위: 0 ~ 2^160-1
- x0 = 0, xn = 2^160-1

이런 해시 공간의 양쪽을 구부려 접으면 그게 해시 링이다.

<br>

### 해시 서버
해시 함수 f를 사용해 서버 IP, 이름을 이 링의 어떤 위치에 대응시킬 수 있다.
위 그림의 Node A, B, C 가 해시 서버다.
<img width="670" alt="스크린샷 2024-10-21 오후 5 47 49" src="https://github.com/user-attachments/assets/894115e1-06e1-4ec9-9a68-17f4925a736f">


<br>

### 해시 키
해시 키 또한 링 위에 배치할 수 있다.
<img width="656" alt="스크린샷 2024-10-21 오후 5 48 12" src="https://github.com/user-attachments/assets/58ebecdb-f725-4cf0-b60f-c0fbdfcec4d4">




<br>

### 서버 조회
해당 키의 위치에서 시계 방향으로 돌다 만나는 첫 번째 서버가 해당 키가 저장되는 서버이다.
<img width="693" alt="스크린샷 2024-10-21 오후 5 48 57" src="https://github.com/user-attachments/assets/387cf479-7857-421e-9ea3-f0dba3f10969">



<br>

### 서버 추가
이 링 위에 하나의 서버(Node D)를 추가하면 초록 구간만 재배치하면 된다.
- 서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.
- 서버 4가 추가된 뒤 key0만 재배치된다. 
- key 0 : 서버 0 -> 서버 4 
<img width="693" alt="스크린샷 2024-10-21 오후 5 49 20" src="https://github.com/user-attachments/assets/ce33661e-9eb7-4827-a703-859a80585347">


<br>

### 서버 제거
노란 구간을 제외하고는 영향이 없다.
- 서버가 제거되더라도 키 가운데 일부만 재배치 된다.
<img width="484" alt="스크린샷 2024-10-21 오후 5 49 42" src="https://github.com/user-attachments/assets/7420569d-5f72-4f9c-8d09-4f6a8214d784">


<br>

### 기본 구현법의 두 가지 문제
- 파티션 크기를 균등하게 유지하는 게 불가능하다.
  - 여기서 파티션은 인접한 서버 사이의 해시 공간.
  - 즉 어떤 서버는 굉장히 작은 공간 할당, 다른 어떤 서버는 굉장히 큰 공간을 할당받을 수 있음.
<img width="439" alt="스크린샷 2024-10-21 오후 5 50 53" src="https://github.com/user-attachments/assets/fd6de9a2-120c-4503-8190-0119d658ef8d">
  
- 키의 균등 분포(uniform distribution)를 달성하기는 어렵다.
  - 위에 서버 제거 그림을 보면, 결국에 Node A에만 키가 몰리는 것을 볼 수 있다.
  - 이런경우를 균등 분포가 깨진다고 할 수 있음.
<img width="523" alt="스크린샷 2024-10-21 오후 5 51 39" src="https://github.com/user-attachments/assets/84eafba2-511e-4181-b2b0-c7c232d58550">


<br>

### 가상 노드
#### 가상 노드(virtual node) 또는 복제(replica)
- 실제 노드 또는 서버를 가리키는 노드.  
- 하나의 서버는 링 위에 여러 개의 가상 노드를 가진다.  
  
서버는 하나가 아닌 여러 개 파티션을 관리해야 한다는 것!
<img width="562" alt="스크린샷 2024-10-21 오후 5 52 08" src="https://github.com/user-attachments/assets/23d428ba-3192-486f-9b8e-04a49e3be0f6">

<br><br>



#### 가상 노드 개수를 늘리면 키의 분포는 점점 더 균등해진다.
표준 편차가 작아지면서 데이터가 고르게 분포될 수 있다.  

- 200개의 가상 노드 사용 시 평균 표준 편차 값 5%
- 100개의 가상 노드 사용 시 평균 표준 편차 값 10%
가상 노드를 많이 사용할수록 저장 공간이 많이 필요하기 때문에 타협적 결정(tradeoff)이 필요하다.

  

<br>

### 재배치할 키 결정
서버가 추가되거나 제거되면 데이터 일부는 재배치 되어야 한다.  
어느 범위의 키들이 재배치 될까?
<img width="689" alt="스크린샷 2024-10-21 오후 5 52 38" src="https://github.com/user-attachments/assets/246226d2-9f1c-427a-bfe4-cedccbf056d7">
- 재배치 범위 : 반시계 방향 (cf. 할당 노드 : 시계 방향 첫 노드)
- 서버 4 ~ 서버 3 (반시계 방향) 범위 재배치 필요 
- key0 서버 0 => 서버 4로 재배치  

<br><br>


<img width="692" alt="스크린샷 2024-10-21 오후 5 53 10" src="https://github.com/user-attachments/assets/9f8474ef-8f90-4b49-ba6b-edb7fdf29e85">

서버 1 ~ 서버 0까지(반시계방향) 재배치 필요 
k1이 s1 -> s2로 재배치된다. 

<br><br><br>


## 마치며
### 안정해시의 이점
- 서버 추가, 삭제 시 재배치되는 키의 수를 최소화한다.
- 데이터가 보다 균등하게 분포되므로, 이는 수평적 규모 확장성에 용이하다
- 핫스팟 키 문제를 줄일 수 있다.(유명인사)


### 사용사례
- 아마존 DynamoDB 파티셔닝 관련 컴포넌트
- 아파치 카산드라 클러스터에서의 데이터 파이셔닝
- 디스코드 채팅 애플리케이션
- 아카마이 CDN
- 매그레프 네트워크 부하 분산기


파티셔닝이나 로드 밸런싯ㅇ에 주로 사용된다.  



