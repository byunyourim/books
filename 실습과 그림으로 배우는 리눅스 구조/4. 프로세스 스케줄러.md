프로세스 스케줄러는 여러 개의 프로세스를 동시에 동작하도록 스케줄링한다. 정확하게는 동시에 동작하는 것이 아닌, 동시에 동작하는 것처럼 보이는 것이다.  

하나의 CPU는 동시에 하나의 프로세스만 처리할 수 있어, 여러 개의 프로세스를 실행해야 하는 경우, 각 프로세스를 적절한 시간으로 나누어 번갈아 처리한다.


<br>

## 스케줄러의 동작
![스케줄링1.png](https://github.com/user-attachments/assets/d5f2d17c-8ab9-437c-9dcf-4d504f7adfbf)

각 프로세스들의 우선순위가 같다고 했을 때, 3개의 프로세스가 논리 CPU 1개를 사용한다면 각 프로세스는 같은 양의 시간 만큼 CPU에서 사용된다.  

시스템에서 CPU로 인식하는 것을 논리 CPU라고 하며, 하이퍼스레딩이 적용된 경우 각 하이퍼스레드가 논리 CPU로 인식된다.


<br>

## 테스트 프로그램으로 작동 방식 확인하기
#### 알고자 하는 정보

- 논리 CPU가 특정 시점에 어떤 프로세스를 실행 중인가
- 각 프로세스의 진행률

#### 테스트 프로그램 사양
- 명령어 라인 파라미터(nproc, total, resolution)
- 파라미터	설명
  nproc	동시 동작 프로세스 수
  total	프로그램이 동작하는 총 시간[ms]
  resolution	데이터 수집 시간 간격[ms]

#### 각 프로세스의 동작 방식
- CPU 시간을 total 밀리초만큼 사용한 후 종료한다.
- CPU 시간을 resolution 밀리초만큼 사용할 때마다 다음 내용을 출력한다.

프로세스고유ID(0 ~ nproc-1)   프로그램시작시점부터경과한시간   진행도[%]




# 고찰

<br><br><br>

# 컨텍스트 스위치

논리 CPU상에서 동작하는 프로세스가 바뀌는 것을 컨텍스트 스위치라 한다.  
<img width="806" alt="스크린샷 2024-09-18 오전 10 38 02" src="https://github.com/user-attachments/assets/6185f144-a88b-4edf-a528-e605e56e8eaa">



<br><br><br>

# 프로세스의 상태
- 실행 상태 : 현재 논리 CPU를 사용
- 실행 대기 상태 : CPU 시간이 할당되기를 대기하는 상태
- 슬립 상태 : 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지 CPU 시간을 사용하지 않는 상태
- 좀비 상태 : 프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 대기하는 상태

#### 슬립 상태에서 기다리는 이벤트의 종류
- 정해진 시간이 경과하는 것을 기다린다.(3분 대기 등)
- 키보드, 마우스 등 사용자의 입력을 기다리는 상태
- HDD, SDD와 같은 저장 장치의 읽고 쓰기의 종료를 기다린다.
- 네트워크의 데이터 송수신 종료를 기다린다.

<br>

|Stat 필드의 첫 문자|상태|
|------|-------|
|R|실행 상태 또는 실행 대기 상태|
|S , D|슬립상태, S는 실행 상태로 되돌아오는 것, D는 되돌아오지 않는 것으로 주로 저장장치의 접근을 대기한다.|
|Z|좀비 상태|

프로세스 대부분은 슬립 상태이다.  

- ps ax는 프로그램이 프로세스의 상태를 출력하기 위해 동작 중이기 때문에 R 상태이다.
- bash는 사용자로부터 입력을 기다리고 있기 때문에 S의 상태를 갖는다.
- D 상태의 프로세스는 일반적으로 수 밀리초가 지나면 다른 상태로 변환된다.
- 장시간 D상태인 경우
  - 스토리지의 I/O가 종료되지 않은 상태
  - 커널 내에 문제가 생긴 경우
<br><br><br>

# 상태 변환
<img width="806" alt="스크린샷 2024-09-18 오전 10 38 02" src="https://github.com/user-attachments/assets/510dd5af-37e2-40eb-a5ff-9ca22d27a813">



<br><br><br>

# idle 상태
프로세스 0이 논리 CPU 0에서 동작하지 않는 시간이 있다. 이 때 논리 CPU에는 idle 프로세스가 동작한다.
idle 프로세스는 아무것도 하지 않는 프로세스이다.  

idle 프로세스의 단순한 구현에는 새로운 프로세스를 생성하거나, 슬립 상태에 있는 프로세스가 깨어날 때까지 의미 없는 루프를 도는 것이다.  
하지만 이런 방식은 전력을 낭비하기 때문에 사용하지 않는다.  

대신 CPU의 명령을 이용해 CPU를 휴식상태로 만든다. 하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 **소비 전력을 낮춰 대기 상태**로 만든다.  
노트북, 스마트폰으로 아무것도 하지 않는 상태일 때 배터리가 오래가는 이유가 바로 논리 CPU가 소비 전력이 낮은 idle상태로 오래 있기 때문이다. 

- sar 명령어를 사용해 단위 시간 당 논리 CPU가 얼마나 idle상태가 되는지, 어느 정도 계산 리소스에 여유가 있는지 확인할 수 있다.



<br><br><br>

# 여러 가지 상태 변환

#### 프로세스 0 만 있는 경우
<img width="796" alt="스크린샷 2024-09-18 오후 1 38 10" src="https://github.com/user-attachments/assets/c0956125-a28b-4187-ac0d-37500a1611b6">

<br>

#### 프로세스 0, 1이 있는 경우
<img width="806" alt="스크린샷 2024-09-18 오후 1 51 19" src="https://github.com/user-attachments/assets/c3619fe5-84b4-450d-bd65-0d4e6108adee">


<br><br><br>

# 스루풋과 레이턴시
스루풋과 레이턴시는 각종 처리의 성능 지표를 나타낸다
- **스루풋 throughput**
  - 단위 시간당 처리된 일의 양, 높을수록 성능이 좋다.ㅇㄹ효 
  - 완료한 프로세스의 수 / 경과 시간
- **레이턴시 latency**
  - 각각이 처리가 시작부터 종료까지 경과된 시간, 짧을수록 성능이 좋다.
  - 처리 종료 시간 - 처리 시작 시간



<br><br><br>



<br><br><br>

# 논리 CPU가 여러 개일때 스케줄링
논리 CPU가 여러 개일 때 로드밸런서, 글로벌 스케줄러를 이용하여 처리한다.  

- loader balancer : 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할
<img width="753" alt="스크린샷 2024-09-18 오후 2 06 33" src="https://github.com/user-attachments/assets/4d674460-5aec-4c61-b5b5-4bfd491d13bb">
<img width="786" alt="스크린샷 2024-09-18 오후 2 07 09" src="https://github.com/user-attachments/assets/3b031be2-ff90-4821-a3f7-12ea4544beab">
<img width="778" alt="스크린샷 2024-09-18 오후 2 07 35" src="https://github.com/user-attachments/assets/b33d3979-d66f-4426-af1a-150c98550e77">


<br><br><br>

# 경과 시간과 사용 시간
time 명령어를 사용하면 경과 시간과 사용 시간을 얻을 수 있다.

- 경과 시간 : 프로세스가 시작해서 종료할 때까지의 경과 시간
- 사용 시간 : 프로세스가 실제로 논리 CPU를 사용한 시간
<img width="808" alt="스크린샷 2024-09-18 오후 2 17 07" src="https://github.com/user-attachments/assets/fa7076f8-4e0c-48e3-b82b-2e5efa77ca82">




<br><br><br>

# 슬립을 사용하는 프로세스





<br><br><br>

# 실제 프로세스




<br><br><br>

# 우선순위 변경
특정 프로세스에 우선 순위를 부여할 수 있다.
   
#### nice()
- -19~20 까지 우선 순위 설정
- 기본값 : 0
- -19가 우선 순위가 가장 높고, 20이 가장 낮다.

우선순위가 높은 프로세스는 CPU 시간을 더 많이 배정받는다.
우선 순위는 내리는 것은 리눅스 사용자 계정 모두 가능
우선 순위를 높이는 것은 root계정만 가능  












 
 
