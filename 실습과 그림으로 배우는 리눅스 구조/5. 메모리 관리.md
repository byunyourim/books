리눅스는 커널의 메모리 관리 시스템으로, 메모리를 관리한다.  


각 프롯세스는 메모리를 사용하고, 커널 자체도 메모리를 사용한다.  
<img width="911" alt="스크린샷 2024-09-17 오전 10 45 28" src="https://github.com/user-attachments/assets/7ab2debf-1b00-486b-abe8-570481057eae">


<br><br><br>


# 메모리의 통계 정보
#### free
시스템의 총 메모리 양, 사용 중인 메모리 양 확인  

- total : 전체 메모리 용량
- free : 표기상 이용하지 않는 메모리
- buff/cache : 버퍼 캐시, 페이지 캐시가 이용하는 메모리, free가 부족한 경우 커널이 해제하는 영역
- available : 실질적으로 사용가능한 메모리, free가 부족한 경우 해제되는 커널 내의 메모리 영역 사이즈를 더한 값
<img width="897" alt="스크린샷 2024-09-17 오전 10 58 06" src="https://github.com/user-attachments/assets/3bd81592-4acc-4d2e-a536-3cbe124344e3">


<br><br><br>

# 메모리 부족
사용 가능한 메모리가 부족해지면 메모리 관리 시스템은 커널 내부의 해제 가능한 메모리 영역을 해제한다.
##### 사용량 증가시 빈 메모리 감소
<img width="826" alt="스크린샷 2024-09-17 오전 11 19 34" src="https://github.com/user-attachments/assets/5d38d3cc-ef3a-4044-a43d-e1cfdd2e0892">
<br>

##### 커널 내부의 해제 가능한 메모리 영역 해제
<img width="909" alt="스크린샷 2024-09-17 오전 11 21 17" src="https://github.com/user-attachments/assets/76f30ffa-a513-4a33-a043-9df51905f209">


이후에도 메모리 사용량이 계속 증가하면 시스템은 **메모리 부족** 상태가 된다.  


OOM Killer : 이러한 경우 메모리 관리 시스템에서는 적절한 프로세스를 선택해 강제 종료(kill)하여 메모리 영역을 해제 시킨다.  

<br><br><br>

# 단순한 메모리 할당  

#### 커널이 프로세스에 메모리를 할당하는 경우
- 프로세스를 생성할 때
- 프로세스를 생성한 뒤 추가로 동적 메모리를 할당할 때

  프로세스가 생성된 후 추가로 메모리가 필요한 경우
  프로세스는 커널에 메모리 확보용 시스템 콜을 호출해서 메모리 할당을 요청한다.

  커널은 메모리 할당을 요청 받으면 필요한 사이즈를 빈 메모리 영역으로부터 잘라내 그 영역의 시작 주소값을 반환한다.

위와 같이 메모리를 할당하는 경우 문제점
- 메모리 단편화
- 다른 용도의 메모리에 접근
- 여러 프로세스 처리 곤란

<br>

## 1. 메모리 단편화 memory fragmentation

<img width="890" alt="스크린샷 2024-09-17 오전 11 40 26" src="https://github.com/user-attachments/assets/e189b8eb-1d8e-427c-8841-7f71c21e7260">

획득과 해제를 반복하는 경우 메모리 단편화 문제가 발생할 수 있다.  
합쳐서 300바이트가 존재하지만 각각 떨어진 위치에 100바이트씩 3개의 영역에 나누어져 존재할 수 있다.
이러한 경우 100바이트보다 큰 영역으로 확보하려고 하면 실패하게 된다.  

- 프로그램이 메모리를 획득할 때마다 얻은 메모리가 몇 개의 영역으로 나누어져 있는지 확인해야 한다
- 100바이트보다 큰 하나의 데이터를 만드는 용도로 사용할 수 없다.

<br>

## 2. 다른 용도의 메모리에 접근 가능  
프로세스가 커널이나 다른 프로세스가 사용하고 있는 주소를 직접 지정하면 그 영역에 직접 접근할 수 있다.
<img width="636" alt="스크린샷 2024-09-17 오전 11 44 46" src="https://github.com/user-attachments/assets/c28b8172-8473-4469-9b08-75f2ab85f65d">

이러한 방식은 데이터가 오염되거나 파괴될 위험이 있다.


<br>

## 3. 여러 프로세스를 다루기 곤란
억지로 주소를 바꾼 다음 매핑해서 동작시켜도 명령과 데이터에섯 지정한 메모리 주솟가 원래의 값과 다르면 정상적으로 동작하지 않는다.


<br><br><br>

# 가상 메모리
프로세스가 시스템에 탑재된 멤모리에 직접 접근하지 않고 가상 주소를 사용하여 간접적으로 접근하는 방식이다.  
프로세스에 보이는 주소를 가상 주소, 시스템에 탑재된 메모리의 실제 주소를 물리 주소라 한다.  
또한 주소에 따라 접근 가능한 범위를 가상 주소 공간이라고 한다.

<br>

프로세스 주소가 100번지에 접근하면 실제 메모리상에서는 주소 600 번지에 있는 데이터에 접근한다.
<img width="904" alt="스크린샷 2024-09-17 오후 12 10 58" src="https://github.com/user-attachments/assets/7cdeac4c-586e-44dc-ae76-3646662774f4">


<br><br><br>

# 페이지 테이블
커널 내부의 페이지 테이블을 이용하여 가상 주소에서 물리 주소로 변환한다.  

가상 메모리는 전체 메모리를 페이지 단위로 관리하기 때문에, 변환은 페이지 단위로 이루어진다.  

- 페이지 테이블 엔트리 : 페이지 테이블에서 한 페이지에 대한 데이터, 가상 주소와 물리 주소의 대응 정보가 존재
- 페이지 사이즈는 CPU의 아키텍처에 따라 다르다.
- x86_64 의 페이지 사이즈는 4KB

프로세스가 가상 주소에 접근하면 CPU는 페이지 테이블의 내용을 참조하여 매핑된 물리 주소로 접근하도록 변환한다.

<br>

#### Page Fault
프로세스가 접근하려는 메모리 페이지가 물리적 메모리에 존재하지 않는 경우 발생하는 이벤트

커널은 프로세스로부터 메모리 접근이 잘못되었다는 내용을 페이지 폴트 핸들러에 전달한다.
그 위 SIGSEGV 시그널을 프로세스에 통지한다.

이 시그널을 받은 프로세스는 강제로 종료된다. 

<br><br><br>

# 프로세스에 메모리를 할당할 때


## 프로세스를 생성할 때
<img width="911" alt="스크린샷 2024-09-17 오후 10 06 24" src="https://github.com/user-attachments/assets/76b6f00a-65ee-469b-a1f3-6c4034f77bb6">

<br>

## 추가적인 메모리 할당
프로세스가 새 메모리를 요구하면 커널은 새로운 메모리를 할당하여 대응하는 페이지 테이블을 작성한 후 할당된 메모리(물리 주소)에 대응하는 가상 주소를 프로세스에 반환한다.
<img width="807" alt="스크린샷 2024-09-18 오전 12 43 13" src="https://github.com/user-attachments/assets/670725aa-911a-4d78-ad33-ebc4f938bb57">

<br><br><br>

# 해결법

## 1. 메모리 단편화의 문제
프로세스의 페이지 테이블을 잘 설정하면 단편화되어있는 물리 메모리 영역을 프로세스의 가상 주소 공간에서는 하나의 큰 영역으로 보이게 할 수 있다.
이러한 방법으로 메모리의 단편화 문제를 해결할 수 있다.  

<br>

## 2. 다른 용도의 메모리에 접근 가능한 문제
가상 주소 공간, 페이지 테이블은 프로세스별로 만들어진다. 
따라섯 다른 프롯세스의 메모리에 접근할 수 없다.  


실제, 구현상의 이유로 커널의 메모리에 대해 모든 프로세스가 가상 주소 공간에 매핑되어 있다.  
커널 자체가 사용하는 메모리에 대응하는 페이지 테이블 엔트리는 CPU가 커널 모드로 실행할 때만 접근이 가능한 '커널 모드 전용' 정보가 추가되어 있다.
따라서 이 부분도 사용자 모드로 동작하는 프로세스는 접근할 수 없다.  


<br>

## 3. 여러 프로세스를 다루기 곤란한 문제
각 프로세스마다 가상 주소 공간이 존재하기 때문에 다른 프로그램과 주소가 겹치지 않는다. 따라서 각자 전용 주소 공간에서 동작하는 프로그램을 만들 수 있다.  


<br><br><br>

# 가상 메모리의 응용
- 파일 맵
- 디맨드 페이징
- Copy on Write 방식의 고속 프로세스 생성
- 스왑
- 계층형 페이지 테이블
- Huge page

<br>

### 1. 파일 맵
프로세스가 파일에 접근할 때,   

파일을 연 뒤 **read(), write(), lseek()** 등의 시스템 콜 호출  

- mmap() : 파일의 내용을 메모리에 읽어 들여 그 영역을 가상 주소 공간에 매핑할 수 있다.

매핑된 파일은 메모리 접근과 같은 방식으로 접근이 가능하다. 접근한 영역은 후에 저장 장치 내에 기록된다.




<br><br><br>

### 2. 디맨드 페이징
프로세스가 생성될 때, mmap() 시스템 콜로 프로세스에 메모리를 할당했을 때 
1. 커널이 필요한 영역에 메모리를 확보
2. 커널이 페이지 테이블을 설정하여 가상 주소 공간을 물리 주소 공간에 매핑

위의 방법은 메모리를 낭비하는 단점이 있다.  이 문제를 해결하기 위해 디맨드 페이징 방식을 사용한다.  

프로세스의 가상 주소 공간 내의 각 페이지에 대응하는 주소는 페이지에 처음 접근할 때 할당된다.  
각 페이지에는 상태를 추가한다.   

프로세스를 생성할 때 
1. 프로세스의 가상 주소 공간 안, 코드 영역, 데이터 영역에 대응하는 페이지에 프로세스가 해당 영역을 얻었다는 정보를 기록한다.
2. 이 시점에섯 물리 메모리는 할당되지 않는다.
3. 프로그램이 엔트리 포인트로부터 실행을 시작할 때는 엔트리 포인트에 대응하는 페이지용 물리 메모리가 할당된다.

   
<br><br><br>

### 3. Copy on Write
페이지 테이블 엔트리 안에 쓰기 권한을 표시하는 필드가 존재한다. 
fork() 시스템 콜을 호출할때 부모 프로세스의 메모리를 자식 프로세스에 복사하지 않고 페이지 테이블만 복사한다. 이 경우 부모 자식 모두, 전체 페이지에 쓰기 권한을 무효화한다.

페이지를 읽는 경우 두 프로세스 모두 공유된 물리 메모리에 접근이 가능하다.
하지만 변경하려고 하는 경우 공유 해제하는 과정이 필요하다.
1. 페이지에 쓰려고 하는 경우 CPU에 페이지 폴트가 발생한다.
2. CPU가 커널 모드로 변경되어 커널의 페이지 폴트 핸들러가 동작한다.
3. 페이지 폴트 핸들러는 접근한 페이지를 다른 장속에 복사하고, 쓰려고 한 프로세스에 할당한 후 내용을 다시 작성한다.
4. 부모, 자식 프로세스 각각 공유각 해제된 페이지에 대응하는 페이지 테이블 엔트리를 업데이트한다.
   - 쓰기를 한 프로세스 쪽에 엔트리는 새롭게 할당된 물리 페이지를 매핑하여 쓰기를 허가한다.
   - 다른 쪽 프로세스의 엔트리에도 쓰기를 허가한다.
  
하지만 fork() 시스템 콜이 성공하더라고 나중에 쓰기가 발생한 뒤, 페이지 폴트 핸들러가 동작할 시점에서 물리 페이지의 빈 영역이 없는 경우 물리 메모리 부족이 발생할 수 있다.




<br><br><br>

### 4. 스왑

메모리 부족에 대응하는 가상 메모리 방식을 이용한 방식  
- 저장 장치의 일부를 일시적으로 메모리 대신 사용하는 방식
- 시스템의 물리 메모리가 부족한 상태가 되어 물리 메모리를 획득할 때, 기존에 사용하던 물리 메모리의 일부를 저장 장치에 저장하여 빈 공간을 만든다.
- 이때, 메모리의 내용이 저장된 영역을 스왑 영역이라고 한다.
- 시스템 관리자가 시스템을 구축할 때 만들어 둔다.
<br>

<img width="907" alt="스크린샷 2024-09-17 오후 12 56 36" src="https://github.com/user-attachments/assets/f4888426-5b83-4caf-8865-96bf58668140">

<br>

프로세스 B 가 물리 메모리에 매핑되지 않은 가상 주소 100 번지에 처음으로 접근한 경우

이때 물리 메모리에 빈 공간이 없으므로 커널은 사용 중인 물리 메모리의 일부를 스왑 영역에 임시 보관한다.  (스왑아웃)

프로세스A가 가상 주소 100~200 번지에 매핑된 물리 주소 600~700번지에 해당하는 페이지를 임시 보관한다.


<img width="900" alt="스크린샷 2024-09-17 오후 1 10 26" src="https://github.com/user-attachments/assets/e14e8f58-7391-4c37-96d2-962cca45c8b1">


<br>

- 스왑 아웃 : 커널은 사용 중인 물리 메모리의 일부를 스왑 영역에 임시로 보관한다.
- 스왑 인 : 스왑 영역에 보관했던 데이터를 물리 메모리에 되돌린다.

<br>
스왑 인, 스왑 아웃을 합쳐 스와핑이라고 부르며, 리눅스에서는 스왑의 단위가 페이지 단위이기 때문에 페이징이라고도 부른다.  

스래싱 상태 : 시스템의 메모리가 만성적으로 부족한 경우, 메모리에 접근할 때마다 스왑 인, 스왑 아웃이 반복되는 현상  


#### swapon --show
시스템의 스왑 영역 확인

#### free
free 로 출력 내용의 Swap: 로 시작하는 부분이 스왑 영역을 나타낸다.  


<br><br><br>


### 5. 계층형 페이지 테이블
페이지 테이블에 필요한 메모리 양을 절약하기 위한 방식이다.



<br><br><br>

### 6. Huge Page
프로세스의 가상 메모리 사용 크기가 증가하면 , 프로세스 페이지 테이블에서 사용하는 물리 메모리양도 증가한다.
Huge page를 사용해 가상 메모리를 많이 사용하는 프로세스에 대해 페이지 테이블에 필요한 메모리 양을 줄일 수 있다.


