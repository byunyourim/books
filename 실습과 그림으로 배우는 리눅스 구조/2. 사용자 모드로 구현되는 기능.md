### 프로세스와 OS의 관계
![프로세스와OS의관계.png](https://github.com/user-attachments/assets/9cb2b403-cabf-4a60-8fe6-58c7fb5e39ca)
사용자 모드의 프로세스 처리부터 시스템 콜을 통한 커널처리를 호출하는 방식이다. 
프로그램 고유의 코드가 호출을 할 수도 있고, 그 코드가 사용하는 라이브러리가 호출을 할 수도 있다.

<br><br><br>

## System Call
프로세스는 프로세스의 생성이나 하드웨어의 조작 등 **커널의 도움이 필요한 경우 시스템 콜을 통해 호출**한다.  


<br>

#### 시스템 콜의 종류
- 프로세스 생성, 삭제
- 메모리 확보, 해제
- 프로세스 간 통신(IPC)
- 네트워크
- 파일 시스템 다루기
- 파일 다루기 (디바이스 접근)

<br>

## CPU의 모드 변경
- 사용자 모드에서 CPU 모드를 변경하려면 반드시 시스템 콜을 거쳐야 한다.
- 시스템 콜은 CPU의 특수한 명령을 실행해야만 호출된다.
- 프로세스는 보통 사용자 모드로 실행되지만, 커널에 처리를 요청하기 위해 시스템 콜을 호출하면 CPU에서는 **인터럽트 이벤트**가 발생한다.
- 인터럽트 이벤트가 발생하며 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널이 동작한다.

요청한 내용의 처리가 완료됨면 커널 내의 시스템 콜이 종료되고, 다시 사용자 모드로 돌아가 프로세스의 동작이 이어서 진행한다.  

![cpu의모드변경.png](https://github.com/user-attachments/assets/8652d51d-cc0f-4a34-8ce5-bc160decc616)

커널은 프로세스가 요청한 내용을 처리하기 전에 프로세스의 요구가 유효한지 확인한다.(메모리의 용량 등)
요구 사항이 맞지 않으면 커널은 시스템 콜을 실패 처리한다.

**유저 프로세스에서 시스템 콜을 통하지 않고 CPU모드를 변경하는 방법은 없다.**

- **strace 커맨드**를 통해 시스템 콜 호출 목록을 조회할 수 있다.
- **sar 커맨드**를 통해 프로세스가 어떤 모드에서 실행하고 있는지의 비율을 확인할 수 있다.
  - 사용자 모드 : user + nice
  - 커널 모드 : system

<br><br><br>


## 시스템 콜 호출의 동작 순서
**strace** 커맨드를 사용하여 프로세스가 호출한 시스템 콜을 확인할 수 있다.
![]()
1. vi hello hello.c

```c
   #include <stdio.h>
  int main(int argc, char **argv){
  
    printf("hellw world ! \n");
    
    return 0;
  }
```

2. gcc -o hello hello.c 컴파일
3. ./hello 실행
4. strace -o hello.log ./hello 로그 저장
   - sudo dtruss ./hello > hello.log

![시스템콜1.png](https://github.com/user-attachments/assets/1f499da8-2171-4da0-9357-4f8630b8e9d9)
![시스템콜2.png](https://github.com/user-attachments/assets/c1603777-828c-488e-b0b2-162695d69ed3)

각각의 줄은 1개의 시스템 콜이다.

### 1. 시스템 콜을 호출하지 않고 무한 루프를 도는 프로그램
```c
int main(void){
	for(;;){}
}
```

```
$ sar -P ALL 1 1

16:45:45     CPU     %user     %nice   %system   %iowait    %steal     %idle
16:45:46     all      0.13     12.59      0.00      0.00      0.00     87.28
16:45:46       0      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       1      0.00    100.00      0.00      0.00      0.00      0.00  <-
16:45:46       2      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       3      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       4      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       5      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       6      0.00      0.00      0.00      0.00      0.00    100.00
16:45:46       7      0.99      0.00      0.00      0.00      0.00     99.01
...
```

![무한루프.png](https://github.com/user-attachments/assets/882560b9-f3b4-4fc6-a07f-17f80edaf8e3)
루프문만 있는 프로세스의 CPU 사용 통계를 보면 1초동안 유저 프로세스, 즉 CPU가 루프문을 처리하기 위해 사용자 모드로 동작하는 것을 확인할 수 있다.

<br>

### 2. 부모 프로세스 id를 얻는 getppid() 시스템 콜을 무한 루프하는 프로그램을 실행해서 측정 
- **getppid()** : 부모 프로세스의 PID(Process ID)를 얻는 시스템 콜

![gettppid.png](https://github.com/user-attachments/assets/a6769f16-9982-4570-86e3-057965cc1cad)

```c
int main(void){
	for(;;){
    //부모의 프로세스 id 얻기(시스템콜호출)
	  getppid();
	}
}
```

```
$ sar -P ALL 1 1

16:49:11     CPU     %user     %nice   %system   %iowait    %steal     %idle
16:49:12     all      0.00      8.53      4.14      0.00      0.00     87.33
16:49:12       0      0.00      0.00      1.01      0.00      0.00     98.99
16:49:12       1      0.00      0.00      0.00      0.00      0.00    100.00
16:49:12       2      28.00     0.00      72.00     0.00      0.00      0.00 <-
16:49:12       3      0.00      0.00      0.00      0.00      0.00    100.00
16:49:12       4      0.00      0.00      0.00      0.00      0.00    100.00
16:49:12       5      0.00      0.00      0.00      0.00      0.00    100.00
16:49:12       6      0.00      0.00      0.00      0.00      0.00    100.00
16:49:12       7      0.00      0.00      0.00      0.00      0.00    100.00
(중략)
```

커널 72%, 사용자 28% 차지한다.
일반적으로 system의 수치가 크면 **시스템 콜이 너무 많이 호출되고 있거나, 시승템에 과부하가 걸린 상태**를 의미한다.


<br>

strace 에 -T 옵션을 붙이면 시스템 콜 처리에 걸리 시간을 마이크로 초 단위로 측정할 수 있다.

<br>

### 3. 시스템 콜의 Wrapper 함수
리눅스에는 프로그램 작성을 돕기 위해 프로세스 대부분에 필요한 라이브러리 함수가 있다.  

- 시스템 콜은 고급언어 (c, java) 에서 직접 호출이 불가능하다.
- 어셈블리 코드를 통해서 호출해야 한다.(어셈블리 코드는 아키텍처에 의존적이므로, 이식성이 떨어진다.)
- 따라서 OS는 내부적으로 시스템 콜을 호출만 하는 시스템 콜 Wrapper를 제공한다.
- 시스템 콜 wrapper는 아키텍처별로 존재하며, 사용자는 고급 언어를 이용해 wrapper 함수 인터페이스에 맞게 호출하면 된다.
![os가없다면.png](https://github.com/user-attachments/assets/7f941f99-e154-4b07-a19e-e324154c92d5)

OS의 도움이 없었다면 각 프로그램은 시스템 콜을 호출할 때마다, 고급언어에서 어셈블리 코드를 호출해야 했을 것이다.


위와 같은 방식은 시간이 오래걸릴 뿐 아니라, 다른 아키텍처에 사용할 수 없어 이식성이 낮으며, 이식할 수 없는 경우도 존재한다.
이러한 문제를 해결하기 위해 OS에서는 내부적으로 시스템 콜 Wrapper함수를 제공한다.  
시스템 콜 Wrapper함수는 시스템 콜을 호출하는 일을 하며, 아키텍처 별로 존재한다. 


![wrapper.png](https://github.com/user-attachments/assets/53969766-d9a9-4c42-9156-ec40cf6de9c2)


<br><br>


## 표준 C 라이브러리
보통 GNU 프로젝트에서 제공하는 glibc를 표준 C라이브러리를 사용한다.
대부분의 C라이브러리들은 glibc이나 libc를 링크하고 있다.

- **ldd 커맨드**를 통해서 링크하고 있는 라이브러리를 확인할 수 있다.
- glibc는 시스템 콜 wrapper 함수를 포함한다.
