리눅스에서는 저장 장치 안에 있는 데이터에 접근할 때 파일 시스템을 통해서 접근한다.  


## 저장 장치의 기능
- 저장 장치 안에 지정된 주소에 대해 특정 사이즈의 데이터를 읽고 쓰는 기능
![저장장치의기능.png](https://github.com/user-attachments/assets/bffcc19d-42d0-4521-9412-48e6a586dbbd)
- 100 기가바이트의 스토리지가 있다.
- 10 기가바이트의 메모리 영역을 주소 50기가바이트 지점에 쓴다

![저장장치의기능.png](https://github.com/user-attachments/assets/a63a3f97-b2c7-42b2-b6a5-dafa4dc05c8b)
- 데이터를 읽어와야 할 경우 데이터를 보관한 주소, 사이즈를 스스로 기억해야 한다.
- 모든 데이터에 대해 주소, 사이즈를 관리해야 한다.

<br>
이런 것을 관리하는 방법이 파일 시스템이다
하나의 데이터의 이름, 위치, 사이즈 등의 부가 정보를 추가하여 파일 단위로 관리한다.
따라서 데이터(파일)의 이름을 알면 저장장치에서의 데이터 위치, 사이즈 등의 정보를 기억할 필요가 없다.

<br><br>

#### 단순한 파일 시스템의 사양
- 0기가 바이트의 지점부터 파일 리스트를 기록한다.
- 하나의 파일에 대해 이름, 장소, 사이즈 세 가지 정보를 기록한다.

사용자 프로세스가 파일 읽기 시스템 콜을 사용하여 파일 이름, 오프셋, 사이즈를 지정하면 파일시스템을 다루는 처리가 해당하는 데이터를 찾아 사용자에게 전달한다.
<img width="915" alt="스크린샷 2024-09-14 오전 12 58 52" src="https://github.com/user-attachments/assets/48efe4a2-59a2-4a77-83dc-c0ea8f862787">



<br><br>

## 리눅스의 파일 시스템
- 디렉터리 : 파일을 보관하는 특수 파일로, 일반 파일 또는 다른 디렉터리 보관 가능하며 트리 구조이다.
<img width="903" alt="스크린샷 2024-09-14 오전 1 15 14" src="https://github.com/user-attachments/assets/18c8eb76-21af-4fba-a680-543d8b5b0a1d">

- 리눅스는 여러 개의 파일 시스템을 다룰 수 있다.
- 각각 저장 장치의 데이터 구조 및 처리하기 위한 프로그램이 다르다.
- 각각의 파일 시스템은 다룰 수 있는 파일, 파일시스템의 사이즈, 처리 속도 등이 다르다.
- 하지만 아래의 시스템 콜을 통해 통일된 인터페이스로 접근할 수 있다.


|시스템  콜	| 동작|
|------|------|
|creat(), unlink()	|파일 생성, 삭제|
|open(), close()|	파일 열기, 닫기|
|read()	|파일로부터 데이터 읽기|
|write()	|파일에 데이터 쓰기|
|lseek()	|파일의 특정 위치로 이동|
|ioctl()|	파일시스템에 의존적인 특수한 처리|


1. 커널 내의 모든 파일시스템 공통 처리가 동작하고 대상 파일의 파일시스템을 판별한다.
2. 각 파일시스템을 처리하는 프로세스를 호출하여 시스템 콜에 대응되는 처리를 한다.
3. 데이터의 읽기를 하는 경우 디바이스 드라이어에 처리를 의뢰한다.
4. 디바이스 드라이버가 데이터를 읽어 들인다.

<img width="787" alt="스크린샷 2024-09-14 오전 1 29 37" src="https://github.com/user-attachments/assets/e826334b-ad81-4396-bddc-df9fc82dc8cf">

파일 시스템에 관계없이 통일된 인터페이스로 접근이 가능하다.



<br><br><br>


## 데이터와 메타데이터
- **데이터** : 사용자가 작성한 문서, 사진, 동영상, 프로그램 등
- **메타 데이터** : 파일의 이름이나 저장 장치 내에 위치 사이즈 등 보조 정보 (종류, 시간정보, 권한정보)


메타데이터는 데이터와 비교해서 사이즈가 작아 큰 용량을 차지하지는 않는다. 하지만 작은 파일을 많이 작성하는 시스템의 경우,
데이터의 총 용량을 측정해보면 실제로 디스크 총 사용량에 비해 상대적으로 적은 용량을 차지하는 경우가 있다.
이러한 경우가 메타데이터가 데이터보다 많은 용량을 차지하는 경우이다.  

<br>

#### 명령어
- df : 파일 시스템의 스토리지 사용량(파일 시스템에 작성하나 모든 파일의 합계 + 메타데이터 사이즈)









<br><br><br>

## 용량 제한
시스템을 여러 가지 용도로 사용하는 경우
특정 용도가 파일 시스템의 용량을 무제한으로 사용할 수 있다면, 다른 용도로 사용할 용량이 부족해진다.
<img width="1012" alt="스크린샷 2024-09-14 오전 2 00 11" src="https://github.com/user-attachments/assets/0df810b1-4143-4b14-a6fd-815a76448953">

#### 쿼터의 종류
- 사용자 쿼터 : 사용자별로 용량 제한, (ext4, XFS)
- 디렉터리 쿼터 : 프로젝트 쿼터라고도 하며, 특정 디렉터리별로 용량을 제한, (ext4, XFS)
- 서브 볼륨 쿼터 : 파일 시스템 내의 서브 볼륨이라는 단위별 용량 제한,(Btrfs)








<br><br><br>

## 파일 시스템이 깨진 경우
파일시스템의 데이터를 스토리지로 쓰는 중에 시스템의 전원이 강제로 끊어지는 경우 파일 시스템의 내용이 깨질 수 있다.  

디렉터리의 이동을 예로 보자.
<img width="976" alt="스크린샷 2024-09-14 오전 2 27 57" src="https://github.com/user-attachments/assets/cb1dc16e-580d-4111-b8af-b28476e8d9ee">


<br>


### 이동 처리의 흐름을 보자
<img width="970" alt="스크린샷 2024-09-14 오전 2 27 50" src="https://github.com/user-attachments/assets/e1d24169-b549-4a6c-ad59-79306a050bb2">


<br>


### 파일시스템이 깨진 경우
<img width="981" alt="스크린샷 2024-09-14 오전 2 27 39" src="https://github.com/user-attachments/assets/cb38b50b-82dc-4e19-9ca6-33973377931e">

파일시스템이 깨지는 것을 막기 위해서는 **저널링과 Copy on Write** 방식이 있다.
- 저널링 : ext4, XFS
- Copy on Write : Btrfs


<br><br><br>

## 저널링
저널링에서는 파일시스템 안에 저널 영역이라는 특수한 영역이 있다.
저널 영역은 사용자가 인식할 수 없는 메타데이터이다.  


#### 파일 시스템을 업데이터하는 순서
1. 업데이트에 필요한 아토믹한 처리의 목록을 저널 영역에 작성한다. 이 목록을 저널 로그라고 한다.
2. 저널 영역의 내용을 바탕으로 파일 시스템의 내용을 업데이트한다.

<img width="989" alt="스크린샷 2024-09-14 오전 2 50 41" src="https://github.com/user-attachments/assets/0debda14-345d-45cc-9539-43c171d92ad5">

<br>

#### 순서 2에서 전원이 끊어진다면?
<img width="1009" alt="스크린샷 2024-09-14 오전 2 55 05" src="https://github.com/user-attachments/assets/8cb87a72-dac9-4c63-822a-4ecc102723f5">
단순히 저널 영역의 데이터를 지워버린다. 따라서 실제 데이터는 처리 전과 같아진다.

<br>
#### 하지만 실제로 데이터를 업데이트하는 중에 강제로 전원이 끊어진다면?
저널로그를 처음부터 다시 수행한다.


<br><br><br>

## Copy on Write


<br><br><br>

## 파일 시스템 깨지는 것을 막을 수 없는 경우


<br><br><br>

## 대책



<br><br><br>

## 파일 종류


<br><br><br>

## 캐릭터 장치


<br><br><br>

## 블록 장치




<br><br><br>

## 여러가지 파일시스템




<br><br><br>

#### 메모리 기반


<br><br><br>

#### 네트워크 파일시스템



<br><br><br>

#### 가상 파일시스템
- procfs
- sysfs
- cgroupfs


<br><br><br>

#### Btrfs
- 멀티볼륨
- 스냅샷
- RAID
- 데이터의 파손 검출, 복구




